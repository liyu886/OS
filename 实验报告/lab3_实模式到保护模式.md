主硬盘分配的端口地址是0x1f0~0x1f7，从硬盘分配的端口地址是0x170~0x177

因为端口是独立编址的，因此我们无法使用mov指令来对端口赋值，我们使用的是in,out指令。读端口使用in指令，写端口使用out指令，in/out指令的操作数有严格规定，如下所示。

```asm
; in指令
in al, 0x21 ; 表示从0x21端口读取一字节数据到al
in ax, 0x21 ; 表示从端口地址0x21读取1字节数据到al，从端口地址0x22读取1字节到ah

mov dx,0x379
in al, dx  ; 从端口0x379读取1字节到al

; out指令
out 0x21, al ; 将al的值写入0x21端口
out 0x21, ax ; 将ax的值写入端口地址0x21开始的连续两个字节
mov dx, 0x378
out dx, ax  ; 将ah和al分别写入端口0x379和0x378
```

使用LBA读取硬盘的方式如下。

1. **设置起始的逻辑扇区号**。由于扇区的读写是连续的，因此只要给出第一个扇区的编号就可以了。由于我们这里使用的是LBA28（28表示使用28位来表示逻辑扇区的编号）的方式读取硬盘，没有一个IO端口能够容纳下28位的地址。此时，逻辑扇区号是被分成4段写入端口的。其中，逻辑扇区的0~7位被写入0x1F3端口，8~15位被写入0x1F4端口，16~23位被写入0x1F5端口，最后4位被写入0x1F6端口的低4位。注意0x1F6的8个位表示如下。我们使用的是LBA模式，只使用主硬盘。因此0x1f6的高4位应该是0xE。

<img src="C:\Users\16435\AppData\Roaming\Typora\typora-user-images\image-20210327202408004.png" alt="image-20210327202408004" style="zoom:67%;" />

2. **将要读取的扇区数量写入0x1F2端口**。由于这是一个8位端口，因此每次最多只能读写255个扇区。

3. **向0x1F7端口写入0x20，请求硬盘读**。

4. **等待其他读写操作完成**。我们在第3步请求硬盘读的时候，可能硬盘在处理其他操作。因此我们需要等待其他读写操作完成后才能开始本次读写操作。硬盘的状态可以从0x1F7读入，读到的8个状态位如下所示。

   <img src="https://gitee.com/nelsoncheung/sysu-2021-spring-operating-system/raw/main/lab3/gallery/0x1f7.PNG" alt="img" style="zoom:60%;" />

   

5. **若在第4步中检测到其他操作已经完成，那么我们就可以正式从硬盘中读取数据**。我们从0x1F0中连续读入一个扇区的数据。0x1F0是硬盘接口的数据端口，16位。

   



读取硬盘的过程写成汇编代码

```asm
asm_read_hard_disk:                           
; 从硬盘读取一个逻辑扇区

; 参数列表
; ax=逻辑扇区号0~15位
; cx=逻辑扇区号16~28位
; ds:bx=读取出的数据放入地址

; 返回值
; bx=bx+512

    mov dx, 0x1f3  ;端口0x1f3是起始地址
    out dx, al    ; LBA地址7~0

    inc dx        ; 0x1f4
    mov al, ah	  
    out dx, al    ; LBA地址15~8

    mov ax, cx

    inc dx        ; 0x1f5
    out dx, al    ; LBA地址23~16

    inc dx        ; 0x1f6
    mov al, ah
    and al, 0x0f  ;将al清零
    or al, 0xe0   ; LBA地址27~24
    out dx, al

    mov dx, 0x1f2	;0x1f2填写读取扇区数量
    mov al, 1
    out dx, al   ; 读取1个扇区

    mov dx, 0x1f7    ; 0x1f7
    mov al, 0x20     ;读命令
    out dx,al

    ; 等待处理其他操作
  .waits:
    in al, dx        ; dx = 0x1f7
    and al,0x88
    cmp al,0x08	；可以进行读取时0x1f7中的数据是0x08
    jnz .waits                         
    

    ; 读取512字节到地址ds:bx
    mov cx, 256   ; 每次读取一个字，2个字节，因此读取256次即可          
    mov dx, 0x1f0
  .readw:
    in ax, dx
    mov [bx], ax
    add bx, 2
    loop .readw
      
    ret
```

##  从实模式到保护模式

CPU需要知道当前运行中程序的段地址空间信息，然后才能执行地址保护，阻止程序越界访问。段地址空间信息是通过段描述符(segment descriptor)来给出的。段描述符中包含了段基地址(段的起始地址)、段界限(段的长度)等，共计64字节，如下所示。上面一行是高32字节、下面一行是低32字节。

![img](https://gitee.com/nelsoncheung/sysu-2021-spring-operating-system/raw/main/lab3/gallery/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6.PNG)

- **段基地址**。段基地址共32位，是段的起始地址，被拆分成三部分放置。
- **G位**。G表示粒度， G=0表示段界限以字节为单位， G=1表示段界限以4KB为单位。
- **D/B位**。D/B位是默认操作数的大小或默认堆栈指针的大小，在保护模式下，该位置为1，表示32位。
- **L位**。L位是 64 位代码段标志，由于这里我们使用的是32位的代码，所以L置0。
- **AVL**。AVL位是保留位。
- **段界限**。段界限表示段的偏移地址范围，我们在后面详细讨论这个问题。
- **P位**。P位是段存在位， P=1表示段存在， P=0表示段不存在。
- **DPL**。DPL指明访问该段必须有的最低优先级，优先级从0-3依次降低，即0拥有最高优先级，3拥有最低优先级。
- **S位**。S位是描述符类型。S=0表示该段是系统段，S=1表示该段位代码段或数据段。
- **TYPE**。TYPE指示代码段或数据段的类型，如下所示。

| 第11位(X) | 第10位(E) | 第9位(W) | 第8位(A) | 含义                     |
| --------- | --------- | -------- | -------- | ------------------------ |
| 0         | 0         | 0        | *        | 只读，向上扩展           |
| 0         | 0         | 1        | *        | 读写，向上扩展           |
| 0         | 1         | 0        | *        | 只读，向下扩展           |
| 0         | 1         | 1        | *        | 读写，向下扩展           |
| 1         | 0         | 0        | *        | 只执行，非一致代码段     |
| 1         | 0         | 1        | *        | 执行、可读，非一致代码段 |
| 1         | 1         | 0        | *        | 只执行，一致代码段       |

向上扩展和向下扩展指的是段的线性基地址和段的线性尾地址的大小关系。例如，对于数据段，尾地址是大于基地址的，因此是向上扩展；对于栈段，栈是从高地址向低地址增长的，因此尾地址是小于基地址的，是向下扩展。CPU通过段描述符中的段线性基地址和段界限来执行段保护，如下所示，假设寻址的地址是offset，读出或写入的长度为length。

在保护模式下，所有段描述符都会被集中放置，这个集中放置的区域被称为全局描述符表(Global Descriptor Table，简称GDT)，GDT其实就是一个段描述符数组。

段寄存器保存的内容是段选择子(segment selector)。在段选择子是用来告诉CPU寻址时使用哪个段。所有的段都会被保存在全局描述符表(GDT)中，实际上段选择子是全局描述符表的索引,但段选择子中还会包含其他信息，如下所示。

![img](https://gitee.com/nelsoncheung/sysu-2021-spring-operating-system/raw/main/lab3/gallery/%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90.PNG)

- 第15-3位是段描述符的索引，表示选择子指向的段描述符是段描述符表中的第几个，编号从 0 开始。
- 第2位用来指示描述符表，0表示描述符表是 GDT。
- 第1-0位是请求特权级，特权级编号为 0-3，权限依次降低，0权限最高。

保护模式下的寻址--选择子:偏移地址

在保护模式下，CPU先通过选择子在描述符表中找到段描述符，然后得到段线性基地址，最后将段线性基地址加上偏移地址便得到线性地址。

GDT实际上是一个段描述符数组，保存在内存中。GDT的起始位置和大小由我们来确定，保存在寄存器GDTR中，GDTR的内容如下所示。

![img](https://gitee.com/nelsoncheung/sysu-2021-spring-operating-system/raw/main/lab3/gallery/GDTR.PNG)



##  进入保护模式

 80286及以后的CPU首先进入实模式，然后通过切换机制再进入到保护模式。也就是说，在BIOS加电启动后，我们需要在实模式下的MBR中编写16位进入保护模式的代码，然后再跳转到保护模式，执行接下来的32位代码。进入保护模式的步骤如下。

1. **准备GDT，用lgdt指令加载GDTR信息**。
2. **打开第21根地址线**。
3. **开启cr0的保护模式标志位**。
4. **远跳转，进入保护模式**。





首先，我们需要定义段描述符，我们有代码段描述符、数据段描述符、栈段描述符和视频段描述符。

**平坦模式:**为了简化地址的访问，我们让所有的程序运行在同一个段中，这个段的地址空间大小是4GB，也就是全部的地址空间。此时，我们让代码段描述符、数据段描述符和栈段描述符中的段线性基地址为0，那么偏移地址和线性地址就完全相同，这大大简化了编程的逻辑。

视频段描述符是显存所在的内存区域的段描述符。