<h4>6.3

基于6.1节对图6.2中路径的描述，简单描述图6.3中的6种路径

<img src="C:\Users\16435\AppData\Roaming\Typora\typora-user-images\image-20210510203613052.png" alt="image-20210510203613052" style="zoom: 80%;" />

1. Q获得B，然后获得A；再后释放B和A；当P恢复执行时，它可以获得全部资源
2. Q获得B，然后获得A；P执行并阻塞在对A的请求上；Q释放B和A；当P恢复执行时，它可以获得全部资源。
3. Q获得B；P获得A，然后释放A；Q获得A，然后释放B，再后释放A；当P恢复执行时，它可以获得全部资源。
4. P获得A；Q获得B；P释放A；Q获得A，然后释放B；再后P获得B，然后释放B。
5. P获得A，再释放A，接着又获得B；Q执行并阻塞在对B的请求上；然后P释放B；当Q再恢复执行时可以获得所有资源。
6. P获得A，再释放A，接着获得B，又释放B；当Q要恢复执行时，它可以获得全部资源。

<h4>6.5

a. 由图知：目前已经被分配的资源
$$
A: 2+0+4+1+1+1=9
$$

$$
B: 0+1+1+0+1+0=3
$$

$$
C: 2+1+0+0+0+1=4
$$

$$
D:1+1+2+1+0+1=6
$$

总资源减去已被分配的资源，即为剩余的可用资源
$$
A:15-9=6
$$

$$
B:6-3=3
$$

$$
C:9-4=5
$$

$$
D:10-6=4
$$

b. c. 如下图所示，c的安全进程序列是：P1->P2->P0->P3->P4->P5

![image-20210510220148565](C:\Users\16435\AppData\Roaming\Typora\typora-user-images\image-20210510220148565.png)

![image-20210510220157517](C:\Users\16435\AppData\Roaming\Typora\typora-user-images\image-20210510220157517.png)

![image-20210510220208390](C:\Users\16435\AppData\Roaming\Typora\typora-user-images\image-20210510220208390.png)

![image-20210510220353005](C:\Users\16435\AppData\Roaming\Typora\typora-user-images\image-20210510220353005.png)

d. 若进程P5的请求为（3， 2， 3， 3）被允许，此时可用资源有（3， 1， 2， 1），C-A的矩阵是

|      |  A   |  B   |  C   |  D   |
| :--: | :--: | :--: | :--: | :--: |
|  P0  |  7   |  5   |  3   |  4   |
|  P1  |  2   |  1   |  2   |  2   |
|  P2  |  3   |  4   |  4   |  2   |
|  P3  |  2   |  3   |  3   |  1   |
|  P4  |  4   |  1   |  2   |  1   |
|  P5  |  0   |  2   |  0   |  0   |

显然，没有一组能够继续进行，该程序会发生死锁，所以该请求不会被允许。；、

<h4>6.6

a. ![image-20210510221230390](C:\Users\16435\AppData\Roaming\Typora\typora-user-images\image-20210510221230390.png)

b. 

```c
void P0(){
    while(true){
        get(A);
        get(B);
        get(C);
        release(A);
        release(B);
        release(C);
    }
}
void P1(){
    while(true){
        get(D);
        get(E);
        get(B);
        release(D);
        release(E);
        release(B);
    }
}
void P2(){
    while(true){
        get(F);
        get(D);
        get(C);
        release(F);
        release(D);
        release(C);
    }
}
```

![image-20210510233851650](C:\Users\16435\AppData\Roaming\Typora\typora-user-images\image-20210510233851650.png)

分析：如图，进程P1 会阻塞在对B的请求上，进程P2会阻塞在对D的请求上；直到进程P0获得资源A、B、C并释放之后，进程P1即可获得资源B，执行它的内容；等到进程P1释放了资源D之后，进程P2再恢复执行，获取资源D 以及C。

<h4>6.15
答：此时系统需要拥有总资源10个，当前可用资源3个，才能保证这是安全状态。

|      |  C   |  A   | C-A  |
| :--: | :--: | :--: | :--: |
|  P1  |  3   |  1   |  2   |
|  P2  |  2   |  1   |  1   |
|  P3  |  9   |  3   |  6   |
|  P4  |  7   |  2   |  5   |

分析：

一开始能让一个进程执行需要至少1个可用资源，给进程P2分配一个资源，进程P2最后可以释放2个，此时共有2个可用资源；

这时可以使进程P1执行，P1释放后共有3个可用资源；

要想资源数最少，则此时还需要额外的2个资源能使进程P4执行，所以一开始初始状态的可用资源数变为3，然后进程P4执行，释放资源后，此时共有7个资源；

接着进程P3会正常执行，释放资源之后，此时有10个资源，所以系统至少拥有的资源总是是10，而一开始的可用资源数是3




<h4>6.18
答：

a. 用反证法，假设存在死锁的情况，即每个哲学家手里都有一把叉子，另一侧的叉子都被邻居所占有。假设Pi是一个左撇子，他左手有叉子而右手没有。那他右侧的Pj，若要满足假设条件，则Pj也必须是一个左撇子，才能使他手里最先拿的是左边的叉子，以此类推整个桌上的人都是左撇子。同理，若有一个右撇子时，要想满足假设条件整个桌上都是右撇子。所以与题中所述的条件，即存在左撇子又存在右撇子相矛盾,假设不成立。所以至少有一个左撇子和一个右撇子，则他们的任何就坐安排都不会出现死锁。

b. 假设Pi是一个左撇子并且他饥饿，也就是说有一部分人在进食，但是Pi始终不会就餐。

第一种情况：Pi没有叉子，那他左边的人Pj是一个右撇子，他一直占着叉子但不能吃完，所以Pj没有左叉子，且他也一直处于饥饿状态。所以Pj左边的人肯定是和Pj出于同样的状态：抓着右叉子但没有左叉子。一直向下推理，所有的哲学家都应该是饥饿状态下的右撇子，这和我们的假设相矛盾。

第二种情况：Pi有左叉子，但没有右叉子。说明他右边的邻居是左撇子且饥饿，同上一种情况，推出所有的哲学家应该是饥饿状态下的左撇子，与假设也相互矛盾。